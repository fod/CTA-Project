{"rule":"OXFORD_SPELLING_Z_NOT_S","sentence":"^\\QThe main() function in main.py initialises the list of algorithms and a list of input array sizes and passes them to the benchmark() function.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe plots are generated, using matplotlib, by the writeplot() function, also defined in main.py.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAs for time complexity, it has already been mentioned that quicksort finishes in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q time for best and average cases.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfirst figure second figure\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QMore formally, if A is a collection, and Ai and Aj are the ith and jth members of that collection, then in order for that collection to be sorted the following condition must be satisfied for all values of i and j ; if Ai < Aj then i < j; and, if Ai = Aj then there must be no k such that i < k < j and Ai \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Ak \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn a collection of items, A, where Ai and Aj are the ith and jth members of that collection, if \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q but \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, then the pair (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) is an inversion \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"WHETHER","sentence":"^\\QHowever, an important property of algorithms as they relate to memory usage which it seems appropriate to include here, is whether or not their sorting is conducted in-place, meaning that no extra copies of the input data need to be made in the process of sorting.\\E$"}
